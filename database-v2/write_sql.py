# Copyright (c) 2025 - Present. IKWF History. All rights reserved.

import pathlib
import sqlite3
from typing import NamedTuple

import pydantic

import bracket_utils

HERE = pathlib.Path(__file__).resolve().parent
ROOT = HERE.parent

# year => { tournament_id => filename }
FILENAMES_BY_YEAR: dict[int, dict[int, str]] = {
    2000: {30: "extracted.2000.json"},
    2001: {32: "extracted.2001.json"},
    2002: {32: "extracted.2002.json"},
    2003: {33: "extracted.2003.json"},
    2004: {34: "extracted.2004.json"},
    2005: {35: "extracted.2005.json"},
    2006: {36: "extracted.2006.json"},
    2007: {37: "extracted.2007.json"},
    2008: {38: "extracted.2008.json"},
    2009: {39: "extracted.2009.json"},
    2010: {40: "extracted.2010.json"},
    2011: {41: "extracted.2011.json"},
    2012: {42: "extracted.2012.json"},
    2013: {43: "extracted.2013.json"},
    2014: {44: "extracted.2014.json"},
    2015: {45: "extracted.2015.json"},
    2016: {46: "extracted.2016.json"},
    2017: {47: "extracted.2017.json"},
    2018: {48: "extracted.2018.json"},
    2019: {49: "extracted.2019.json"},
    2020: {10050: "extracted.2020.json"},
    2022: {50: "extracted.2022.json"},
    2023: {51: "extracted.2023.json"},
    2024: {52: "extracted.2024.json", 10052: "extracted.2024-intermediate.json"},
    2025: {53: "extracted.2025.json"},
}


class _ForbidExtra(pydantic.BaseModel):
    model_config = pydantic.ConfigDict(extra="forbid")


def _validate_division_sort_key():
    with sqlite3.connect(HERE / "ikwf.sqlite") as connection:
        connection.row_factory = sqlite3.Row

        cursor = connection.cursor()
        cursor.execute("SELECT id, key FROM division")
        division_rows = [dict(row) for row in cursor.fetchall()]
        cursor.close()

    for division_row in division_rows:
        actual_id = division_row["id"]
        division = division_row["key"]
        sort_id = bracket_utils.division_sort_key(division)
        if actual_id != sort_id:
            raise ValueError("Mismatch", division, actual_id, sort_id)


class TeamRow(_ForbidExtra):
    id_: int = pydantic.Field(alias="id")
    name_normalized: str


class Inserts(_ForbidExtra):
    team_rows: list[TeamRow]


def _handle_tournament(
    year: int, extracted: bracket_utils.ExtractedTournament
) -> Inserts:
    # 1. `TeamRow` (allow duplicates across year and division)
    team_rows: list[TeamRow] = []

    return Inserts(team_rows=team_rows)


def _handle_year(extracted_dir: pathlib.Path, year: int, filenames: dict[int, str]):
    for _, filename in filenames.items():
        with open(extracted_dir / filename) as file_obj:
            extracted = bracket_utils.ExtractedTournament.model_validate_json(
                file_obj.read()
            )

        _handle_tournament(year, extracted)

        with open(extracted_dir / filename, "w") as file_obj:
            file_obj.write(extracted.model_dump_json(indent=2))
            file_obj.write("\n")


class BracketInfoTuple(NamedTuple):
    weight: int
    division: bracket_utils.Division
    tournament_id: int


class BracketInfo(_ForbidExtra):
    weight: int
    division: bracket_utils.Division
    tournament_id: int

    def as_tuple(self) -> BracketInfoTuple:
        """Convert to a (hashable) tuple."""
        return BracketInfoTuple(
            weight=self.weight, division=self.division, tournament_id=self.tournament_id
        )


def _write_brackets_sql() -> dict[BracketInfo, int]:
    with open(HERE / "_weight-classes.json") as file_obj:
        weight_classes = bracket_utils.WeightClassesByYear.model_validate_json(
            file_obj.read()
        )

    lines = [
        "-- Copyright (c) 2025 - Present. IKWF History. All rights reserved.",
        "",
        "-- Generated by `write_sql.py`",
        "",
        "PRAGMA foreign_keys = ON;",
        "PRAGMA encoding = 'UTF-8';",
        "PRAGMA integrity_check;",
        "",
        "--------------------------------------------------------------------------------",
        "",
        "INSERT INTO",
        "  bracket (id, weight, division, tournament_id)",
        "VALUES",
    ]

    result: dict[BracketInfo, int] = {}

    years = sorted(weight_classes.root.keys())
    current_id = 1
    for i, year in enumerate(years):
        last_i = i == len(years) - 1
        by_tournament = weight_classes.root[year]
        tournament_ids = sorted(by_tournament.keys())
        for j, tournament_id in enumerate(tournament_ids):
            last_j = j == len(tournament_ids) - 1
            by_division = by_tournament[tournament_id]
            divisions = sorted(by_division.keys(), key=bracket_utils.division_sort_key)
            for k, division in enumerate(divisions):
                last_k = k == len(divisions) - 1
                weights = by_division[division]
                for l, weight in enumerate(weights):
                    last_l = l == len(weights) - 1
                    last_line = last_i and last_j and last_k and last_l
                    line_ending = ";" if last_line else ","

                    lines.append(
                        f"  ({current_id}, {weight}, '{division}', "
                        f"{tournament_id}){line_ending}"
                    )

                    info = BracketInfo(
                        weight=weight, division=division, tournament_id=tournament_id
                    )
                    key = info.as_tuple()
                    if key in result:
                        raise KeyError("Duplicate", key)
                    result[key] = current_id

                    # Prepare for next iteration
                    current_id += 1

    lines.append("")

    with open(HERE / "migrations" / "0004-brackets.sql", "w") as file_obj:
        file_obj.write("\n".join(lines))

    return result


def main():
    _validate_division_sort_key()
    bracket_id_info = _write_brackets_sql()

    extracted_dir = HERE.parent / "intermediate-data"
    for year, filenames in FILENAMES_BY_YEAR.items():
        _handle_year(extracted_dir, year, filenames)


if __name__ == "__main__":
    main()
